var Completable=function(e,r){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r;const n=(e,r)=>typeof e===r,o=e=>n(e,"function"),t=e=>n(e,"number"),c=e=>n(e,"object"),s=e=>null==e,l=e=>null!=e,i=(e,r)=>e instanceof r,u=e=>i(e,Array),a=e=>c(e)&&o(e[Symbol.iterator]),b=e=>c(e)&&o(e.onSubscribe),h=e=>null!=e&&(!!i(e,Promise)||(c(e)||o(e))&&o(e.then)),m=e=>e,p=e=>{throw e},f=e=>({onSubscribe:e.onSubscribe,onComplete:o(e.onComplete)?e.onComplete:m,onError:o(e.onError)?e.onError:p}),C=(r,n)=>{const{onSubscribe:o,onError:t}=f(r),c=new e.BooleanCancellable;o(c),c.cancelled||(t(n),c.cancel())};function E(e){let r;try{if(r=this.supplier(),s(r))throw new Error("Completable.error: Error supplier returned a null value.")}catch(e){r=e}C(e,r)}var d=e=>{let r=e;i(e,Error)||o(e)||(r=new Error("Completable.error received a non-Error value.")),o(r)||(r=(e=>()=>e)(r));const n=new He(E);return n.supplier=r,n},w=e=>e instanceof He;function S(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this;for(const e of s){if(c.cancelled)return;if(!w(e)){o(new Error("Completable.amb: One of the sources is a non-Completable.")),c.cancel();break}e.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){n(),c.cancel()},onError(e){o(e),c.cancel()}})}}var v=e=>{if(!a(e))return d(new Error("Completable.amb: sources is not Iterable."));const r=new He(S);return r.sources=e,r};function k(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),{sources:c}=this,{length:s}=c;if(0===s)C(r,new Error("Completable.ambArray: sources Array is empty."));else{const r=new e.CompositeCancellable;t(r);for(let e=0;e<s;e+=1){const t=c[e];if(r.cancelled)return;if(!w(t)){o(new Error("Completable.ambArray: One of the sources is a non-Completable.")),r.cancel();break}t.subscribeWith({onSubscribe(e){r.add(e)},onComplete(){n(),r.cancel()},onError(e){o(e),r.cancel()}})}}}var y=e=>{if(!u(e))return d(new Error("Completable.ambArray: sources is not an Array."));const r=new He(k);return r.sources=e,r},W=(e,r)=>w(r)?y([e,r]):e;function A(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),c=new e.LinkedCancellable;t(c);const{sources:l}=this,{length:i}=l,u=[];for(let e=0;e<i;e+=1){const r=l[e];if(!w(r))return o(new Error("Completable.concatArray: One of the sources is a non-Completable.")),void c.cancel();u.unshift(r)}let a;for(let e=0;e<i;e+=1){const r=u[e];if(s(a))a=(()=>{r.subscribeWith({onSubscribe(e){c.link(e)},onComplete:n,onError:o})});else{const e=a;a=(()=>{r.subscribeWith({onSubscribe(e){c.link(e)},onComplete(){c.unlink(),e()},onError:o})})}}a()}var L=e=>{if(!u(e))return d(new Error("Completable.concatArray: sources is non-Array."));const r=new He(A);return r.sources=e,r},g=(e,r)=>w(r)?L([e,r]):e;function O(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),{source:c,cached:l,observers:i,subscribed:u}=this;if(l){const r=new e.BooleanCancellable;t(r);const{error:c}=this;s(c)?o(c):n(),r.cancel()}else{const n=i.length;i[n]=r;const o=new e.BooleanCancellable;o.addEventListener("cancel",()=>{i.splice(n,1)}),t(o),u||(c.subscribeWith({onSubscribe(){},onComplete:()=>{this.cached=!0;for(const e of i)e.onComplete();o.cancel(),this.observers=void 0},onError:e=>{this.cached=!0,this.error=e;for(const r of i)r.onError(e);o.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var P=e=>{const r=new He(O);return r.source=e,r.cached=!1,r.subscribed=!1,r.observers=[],r};let x;var B=()=>(s(x)&&(x=new He(r=>(r=>{const{onSubscribe:n,onComplete:o}=f(r),t=new e.BooleanCancellable;n(t),t.cancelled||(o(),t.cancel())})(r))),x),I=(e,r)=>{if(!o(r))return e;let n;try{if(n=r(e),!w(n))throw new Error("Completable.compose: transformer returned a non-Completable.")}catch(e){n=d(e)}return n};function T(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),c=new e.LinkedCancellable;t(c);const{sources:l}=this,i=[];for(const e of l){if(!w(e))return o(new Error("Completable.concat: One of the sources is a non-Completable.")),void c.cancel();i.unshift(e)}let u;for(const e of i)if(s(u))u=(()=>{e.subscribeWith({onSubscribe(e){c.link(e)},onComplete:n,onError:o})});else{const r=u;u=(()=>{e.subscribeWith({onSubscribe(e){c.link(e)},onComplete(){c.unlink(),r()},onError:o})})}u()}var U=e=>{if(!a(e))return d(new Error("Completable.concat: sources is not Iterable."));const r=new He(T);return r.sources=e,r};const N=new WeakMap;class R extends e.Cancellable{constructor(r,n){super(),this.complete=r,this.error=n,N.set(this,new e.BooleanCancellable)}get cancelled(){return N.get(this).cancelled}cancel(){return N.get(this).cancel()}setCancellable(r){if(r instanceof e.Cancellable){if(!this.cancelled){if(r.cancelled)return this.cancel(),!0;{const e=N.get(this);return N.set(this,r),e.cancel(),!0}}r.cancel()}return!1}onComplete(){if(!this.cancelled)try{this.complete()}finally{this.cancel()}}onError(e){let r=e;if(e instanceof Error||(r=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(r)}finally{this.cancel()}}}function D(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),t=new R(r,n);o(t);try{this.subscriber(t)}catch(e){t.onError(e)}}var j=e=>{if(!o(e))return d(new Error("Completable.create: There are no subscribers."));const r=new He(D);return r.subscriber=e,r};function F(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e);let t,c;try{if(t=this.supplier(),!w(t))throw new Error("Completable.defer: supplier returned a non-Completable.")}catch(e){c=e}l(c)?C(e,c):t.subscribeWith({onSubscribe:o,onComplete:r,onError:n})}var M=e=>{const r=new He(F);return r.supplier=e,r};function q(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),{amount:c,scheduler:s,doDelayError:l}=this,i=new e.LinkedCancellable;t(i),this.source.subscribeWith({onSubscribe(e){i.link(e)},onComplete(){i.link(s.delay(()=>{n()},c))},onError(e){i.link(s.delay(()=>{o(e)},l?c:0))}})}var z=(e,n,o,c)=>{if(!t(n))return e;let s=o;i(s,r.interface)||(s=r.current);const l=new He(q);return l.source=e,l.amount=n,l.scheduler=s,l.doDelayError=c,l};function G(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),{amount:c,scheduler:s}=this,l=new e.LinkedCancellable;t(l),l.link(s.delay(()=>{l.unlink(),this.source.subscribeWith({onSubscribe(e){l.link(e)},onComplete:n,onError:o})},c))}var H=(e,n,o)=>{if(!t(n))return e;let c=o;i(c,r.interface)||(c=r.current);const s=new He(G);return s.source=e,s.amount=n,s.scheduler=c,s};function J(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){r(),c()},onError(e){n(e),c()}})}var K=(e,r)=>{if(!o(r))return e;const n=new He(J);return n.source=e,n.callable=r,n};function Q(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;let s=!1;t.subscribeWith({onSubscribe(e){e.addEventListener("cancel",()=>{s||(c(),s=!0)}),o(e)},onComplete(){r(),s||(c(),s=!0)},onError(e){n(e),s||(c(),s=!0)}})}var V=(e,r)=>{if(!o(r))return e;const n=new He(Q);return n.source=e,n.callable=r,n};function X(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe(e){e.addEventListener("cancel",c),o(e)},onComplete:r,onError:n})}var Y=(e,r)=>{if(!o(r))return e;const n=new He(X);return n.source=e,n.callable=r,n};function Z(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){c(),r()},onError:n})}var $=(e,r)=>{if(!o(r))return e;const n=new He(Z);return n.source=e,n.callable=r,n};function _(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete:r,onError(e){c(e),n(e)}})}var ee=(e,r)=>{if(!o(r))return e;const n=new He(_);return n.source=e,n.callable=r,n};function re(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){c(),r()},onError(e){c(void 0,e),n(e)}})}var ne=(e,r)=>{if(!o(r))return e;const n=new He(re);return n.source=e,n.callable=r,n};function oe(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe(e){c(e),o(e)},onComplete:r,onError:n})}var te=(e,r)=>{if(!o(r))return e;const n=new He(oe);return n.source=e,n.callable=r,n};function ce(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(e){c(),r(e)},onError(e){c(),n(e)}})}var se=(e,r)=>{if(!o(r))return e;const n=new He(ce);return n.source=e,n.callable=r,n};function le(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),t=new R(r,n);o(t),this.promise.then(()=>t.onComplete(),e=>t.onError(e))}var ie=e=>{if(!h(e))return d(new Error("Completable.fromPromise: expects a Promise-like value."));const r=new He(le);return r.promise=e,r};function ue(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),t=new R(r,n);let c;o(t);try{c=this.callable()}catch(e){return void t.onError(e)}h(c)?ie(c).subscribeWith({onSubscribe(e){t.setCancellable(e)},onComplete(){t.onComplete()},onError(e){t.onError(e)}}):t.onComplete()}var ae=e=>{if(!o(e))return d(new Error("Completable.fromCallable: callable received is not a function."));const r=new He(ue);return r.callable=e,r};function be(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),t=new R(r,n);o(t),this.subscriber(()=>t.onComplete(),e=>t.onError(e))}var he=e=>{if(!o(e))return d(new Error("Completable.fromResolvable: expects a function."));const r=new He(be);return r.subscriber=e,r};function me(e){let r;try{if(r=this.operator(e),!b(r))throw new Error("Completable.lift: operator returned a non-Observer.")}catch(r){return void C(e,r)}this.source.subscribeWith(r)}var pe=(e,r)=>{if(!o(r))return e;const n=new He(me);return n.source=e,n.operator=r,n};function fe(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this,l=[];for(const e of s){if(!w(e))return o(new Error("Completable.merge: One of the sources is a non-Completable.")),void c.cancel();l.unshift(e)}let i=l.length;for(const e of l)e.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){0===(i-=1)&&(n(),c.cancel())},onError(e){o(e),c.cancel()}})}var Ce=e=>{if(!a(e))return d(new Error("Completable.merge: sources is not Iterable."));const r=new He(fe);return r.sources=e,r};function Ee(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this,{length:l}=s;for(let e=0;e<l;e+=1){const r=s[e];if(!w(r))return o(new Error("Completable.mergeArray: One of the sources is a non-Completable.")),void c.cancel()}let i=l;for(let e=0;e<l;e+=1){s[e].subscribeWith({onSubscribe(e){c.add(e)},onComplete(){0===(i-=1)&&(n(),c.cancel())},onError(e){o(e),c.cancel()}})}}var de=e=>{if(!u(e))return d(new Error("Completable.merge: sources is non-Array."));const r=new He(Ee);return r.sources=e,r},we=(e,r)=>w(r)?de([e,r]):e;function Se(r){r.onSubscribe(e.UNCANCELLED)}let ve;var ke=()=>(void 0===ve&&(ve=new He(Se)),ve);function ye(r){const{onSubscribe:n,onComplete:o,onError:t}=f(r),{source:c,scheduler:s}=this,l=new e.LinkedCancellable;n(l),c.subscribeWith({onSubscribe(e){l.link(e)},onComplete(){l.link(s.schedule(o))},onError(e){l.link(s.schedule(()=>{t(e)}))}})}var We=(e,n)=>{let o=n;i(o,r.interface)||(o=r.current);const t=new He(ye);return t.source=e,t.scheduler=o,t};function Ae(e){const{onComplete:r,onError:n,onSubscribe:o}=f(e),{source:t,item:c}=this;t.subscribeWith({onSubscribe:o,onComplete:r,onError(e){let o;try{o=c(e)}catch(r){return void n([e,r])}o?r():n(e)}})}var Le=(e,r)=>{if(!o(r))return e;const n=new He(Ae);return n.source=e,n.item=r,n};function ge(r){const{onComplete:n,onError:t,onSubscribe:c}=f(r),{source:s,resumeIfError:l}=this,i=new e.LinkedCancellable;c(i),s.subscribeWith({onSubscribe(e){i.link(e)},onComplete:n,onError(e){let r;if(i.unlink(),o(l))try{if(!((r=l(e))instanceof He))throw new Error("Completable.onErrorResumeNext: returned an non-Completable.")}catch(r){return t(new Error([e,r])),void i.cancel()}else r=l;r.subscribeWith({onSubscribe(e){i.link(e)},onComplete:n,onError:t})}})}var Oe=(e,r)=>{if(!(o(r)||r instanceof He))return e;const n=new He(ge);return n.source=e,n.resumeIfError=r,n};function Pe(r){const{onSubscribe:n,onComplete:o,onError:c}=f(r),s=new e.LinkedCancellable;n(s);const{source:l,times:i}=this;let u=-1;const a=()=>{s.unlink(),u+=1,l.subscribeWith({onSubscribe(e){s.link(e)},onComplete(){t(i)?u<=i?a():(o(),s.cancel()):a()},onError:c})};a()}var xe=(e,r)=>{if(l(r)){if(!t(r))return e;if(r<=0)return e}const n=new He(Pe);return n.source=e,n.times=r,n};function Be(r){const{onSubscribe:n,onComplete:t,onError:c}=f(r),s=new e.LinkedCancellable;n(s);const{source:l,predicate:i}=this,u=()=>{s.unlink(),l.subscribeWith({onSubscribe(e){s.link(e)},onComplete(){if(o(i)){i()?(t(),s.cancel()):u()}else u()},onError:c})};u()}var Ie=(e,r)=>{const n=new He(Be);return n.source=e,n.predicate=r,n};function Te(r){const{onSubscribe:n,onComplete:t,onError:c}=f(r),s=new e.LinkedCancellable;n(s);const{source:l,bipredicate:i}=this;let u=-1;const a=()=>{s.unlink(),u+=1,l.subscribeWith({onSubscribe(e){s.link(e)},onComplete:t,onError(e){if(o(i)){i(u,e)?a():(c(e),s.cancel())}else a()}})};a()}var Ue=(e,r)=>{const n=new He(Te);return n.source=e,n.bipredicate=r,n},Ne=(e,r)=>w(r)?L([r,e]):e;function Re(r){const{onSubscribe:n,onComplete:o,onError:t}=f(r),{source:c,scheduler:s}=this,l=new e.LinkedCancellable;n(l),l.link(s.schedule(()=>{l.unlink(),c.subscribeWith({onSubscribe(e){l.link(e)},onComplete:o,onError:t})}))}var De=(e,n)=>{let o=n;i(o,r.interface)||(o=r.current);const t=new He(Re);return t.source=e,t.scheduler=o,t};function je(r){const{onSubscribe:n,onComplete:o,onError:t}=f(r),c=new e.CompositeCancellable;n(c);const{source:s,other:l}=this;l.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){t(new Error("Completable.takeUntil: Source cancelled by other Completable.")),c.cancel()},onError(e){t(new Error(["Completable.takeUntil: Source cancelled by other Completable.",e])),c.cancel()}}),s.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){o(),c.cancel()},onError(e){t(e),c.cancel()}})}const Fe=(e,r)=>{if(!w(r))return e;const n=new He(je);return n.source=e,n.other=r,n};function Me(r){const{onComplete:n,onError:o,onSubscribe:t}=f(r),{amount:c,scheduler:s}=this,l=new e.LinkedCancellable;t(l);const i=s.delay(()=>{o(new Error("Completable.timeout: TimeoutException (no success signals within the specified timeout).")),l.cancel()},c);l.addEventListener("cancel",()=>i.cancel()),this.source.subscribeWith({onSubscribe(e){l.link(e)},onComplete:n,onError:o})}var qe=(e,n,o)=>{if(!t(n))return e;let c=o;i(c,r.interface)||(c=r.current);const s=new He(Me);return s.source=e,s.amount=n,s.scheduler=c,s};function ze(e){const{onComplete:r,onSubscribe:n}=f(e);n(this.scheduler.delay(r,this.amount))}var Ge=(e,n)=>{if(!t(e))return d(new Error('Completable.timer: "amount" is not a number.'));let o=n;i(o,r.interface)||(o=r.current);const c=new He(ze);return c.amount=e,c.scheduler=o,c};class He{constructor(e){this.subscribeActual=e}static amb(e){return v(e)}static ambArray(e){return y(e)}ambWith(e){return W(this,e)}andThen(e){return g(this,e)}cache(){return P(this)}static complete(){return B()}compose(e){return I(this,e)}static concat(e){return U(e)}static concatArray(e){return L(e)}concatWith(e){return g(this,e)}static create(e){return j(e)}static defer(e){return M(e)}delay(e,r,n){return z(this,e,r,n)}delaySubscription(e,r){return H(this,e,r)}doAfterTerminate(e){return K(this,e)}doFinally(e){return V(this,e)}doOnCancel(e){return Y(this,e)}doOnComplete(e){return $(this,e)}doOnError(e){return ee(this,e)}doOnEvent(e){return ne(this,e)}doOnSubscribe(e){return te(this,e)}doOnTerminate(e){return se(this,e)}static error(e){return d(e)}static fromCallable(e){return ae(e)}static fromPromise(e){return ie(e)}static fromResolvable(e){return he(e)}lift(e){return pe(this,e)}static merge(e){return Ce(e)}static mergeArray(e){return de(e)}mergeWith(e){return we(this,e)}static never(){return ke()}observeOn(e){return We(this,e)}onErrorComplete(e){return Le(this,e)}onErrorResumeNext(e){return Oe(this,e)}repeat(e){return xe(this,e)}retry(e){return Ue(this,e)}repeatUntil(e){return Ie(this,e)}startWith(e){return Ne(this,e)}subscribeOn(e){return De(this,e)}takeUntil(e){return Fe(this,e)}timeout(e,r){return qe(this,e,r)}static timer(e,r){return Ge(e,r)}subscribeWith(e){b(e)&&this.subscribeActual.call(this,e)}subscribe(r,n){const o=new e.LinkedCancellable;return this.subscribeWith({onSubscribe(e){o.link(e)},onComplete:r,onError:n}),o}toPromise(){return new Promise((e,r)=>{this.subscribe(e,r)})}then(e,r){return this.toPromise().then(e,r)}catch(e){return this.toPromise().catch(e)}}return He}(Cancellable,Scheduler);