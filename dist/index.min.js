var Completable=function(e,r){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r;const n=(e,r)=>typeof e===r,o=e=>n(e,"function"),t=e=>n(e,"number"),c=e=>n(e,"object"),s=e=>c(e)&&o(e[Symbol.iterator]),i=e=>c(e)&&o(e.onSubscribe),l=e=>null!=e&&(e instanceof Promise||(c(e)||o(e))&&o(e.then)),u=e=>e,a=e=>{throw e},b=e=>({onSubscribe:e.onSubscribe,onComplete:o(e.onComplete)?e.onComplete:u,onError:o(e.onError)?e.onError:a}),h=r=>{const{onSubscribe:n,onComplete:o}=b(r),t=new e.BooleanCancellable;n(t),t.cancelled||(o(),t.cancel())},m=(r,n)=>{const{onSubscribe:o,onError:t}=b(r),c=new e.BooleanCancellable;o(c),c.cancelled||(t(n),c.cancel())};function f(e){let r;try{if(null==(r=this.supplier()))throw new Error("Completable.error: Error supplier returned a null value.")}catch(e){r=e}m(e,r)}var p=e=>{let r=e;e instanceof Error||"function"==typeof e||(r=new Error("Completable.error received a non-Error value.")),"function"!=typeof e&&(r=(e=>()=>e)(r));const n=new Ne(f);return n.supplier=r,n};function C(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this;for(const e of s){if(c.cancelled)return;if(!(e instanceof Ne)){o(new Error("Completable.amb: One of the sources is a non-Completable.")),c.cancel();break}e.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){n(),c.cancel()},onError(e){o(e),c.cancel()}})}}var E=e=>{if(!s(e))return p(new Error("Completable.amb: sources is not Iterable."));const r=new Ne(C);return r.sources=e,r},d=(e,r)=>r instanceof Ne?E([e,r]):e;function w(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),c=new e.LinkedCancellable;t(c);const{sources:s}=this,i=[];for(const e of s){if(!(e instanceof Ne))return o(new Error("Completable.amb: One of the sources is a non-Completable.")),void c.cancel();i.unshift(e)}let l;for(const e of i)if(void 0===l)l=(()=>{e.subscribeWith({onSubscribe(e){c.link(e)},onComplete:n,onError:o})});else{const r=l;l=(()=>{e.subscribeWith({onSubscribe(e){c.link(e)},onComplete(){c.unlink(),r()},onError:o})})}l()}var S=e=>{if(!s(e))return p(new Error("Completable.concat: sources is not Iterable."));const r=new Ne(w);return r.sources=e,r},v=(e,r)=>r instanceof Ne?S([e,r]):e;function k(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),{source:c,cached:s,observers:i,subscribed:l}=this;if(s){const r=new e.BooleanCancellable;t(r);const{error:c}=this;null!=c?o(c):n(),r.cancel()}else{const n=i.length;i[n]=r;const o=new e.BooleanCancellable;o.addEventListener("cancel",()=>{i.splice(n,1)}),t(o),l||(c.subscribeWith({onSubscribe(){},onComplete:()=>{this.cached=!0;for(const e of i)e.onComplete();o.cancel(),this.observers=void 0},onError:e=>{this.cached=!0,this.error=e;for(const r of i)r.onError(e);o.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var W=e=>{const r=new Ne(k);return r.source=e,r.cached=!1,r.subscribed=!1,r.observers=[],r};function y(e){h(e)}let L;var O=()=>(void 0===L&&(L=new Ne(y)),L),g=(e,r)=>{if(!o(r))return e;let n;try{if(!((n=r(e))instanceof Ne))throw new Error("Completable.compose: transformer returned a non-Completable.")}catch(e){n=p(e)}return n};const P=new WeakMap;class x extends e.Cancellable{constructor(r,n){super(),this.complete=r,this.error=n,P.set(this,new e.BooleanCancellable)}get cancelled(){return P.get(this).cancelled}cancel(){return P.get(this).cancel()}setCancellable(r){if(r instanceof e.Cancellable){if(!this.cancelled){if(r.cancelled)return this.cancel(),!0;{const e=P.get(this);return P.set(this,r),e.cancel(),!0}}r.cancel()}return!1}onComplete(){if(!this.cancelled)try{this.complete()}finally{this.cancel()}}onError(e){let r=e;if(e instanceof Error||(r=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(r)}finally{this.cancel()}}}function B(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),t=new x(r,n);o(t);try{this.subscriber(t)}catch(e){t.onError(e)}}var I=e=>{if("function"!=typeof e)return p(new Error("Completable.create: There are no subscribers."));const r=new Ne(B);return r.subscriber=e,r};function T(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e);let t,c;try{if(!((t=this.supplier())instanceof Ne))throw new Error("Completable.defer: supplier returned a non-Completable.")}catch(e){c=e}null!=c?m(e,c):t.subscribeWith({onSubscribe:o,onComplete:r,onError:n})}var U=e=>{const r=new Ne(T);return r.supplier=e,r};function A(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),{amount:c,scheduler:s,doDelayError:i}=this,l=new e.LinkedCancellable;t(l),this.source.subscribeWith({onSubscribe(e){l.link(e)},onComplete(){l.link(s.delay(()=>{n()},c))},onError(e){l.link(s.delay(()=>{o(e)},i?c:0))}})}var N=(e,n,o,c)=>{if(!t(n))return e;let s=o;s instanceof r.interface||(s=r.current);const i=new Ne(A);return i.source=e,i.amount=n,i.scheduler=s,i.doDelayError=c,i};function R(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),{amount:c,scheduler:s}=this,i=new e.LinkedCancellable;t(i),i.link(s.delay(()=>{i.unlink(),this.source.subscribeWith({onSubscribe(e){i.link(e)},onComplete:n,onError:o})},c))}var D=(e,n,o)=>{if(!t(n))return e;let c=o;c instanceof r.interface||(c=r.current);const s=new Ne(R);return s.source=e,s.amount=n,s.scheduler=c,s};function j(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){r(),c()},onError(e){n(e),c()}})}var F=(e,r)=>{if(!o(r))return e;const n=new Ne(j);return n.source=e,n.callable=r,n};function M(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;let s=!1;t.subscribeWith({onSubscribe(e){e.addEventListener("cancel",()=>{s||(c(),s=!0)}),o(e)},onComplete(){r(),s||(c(),s=!0)},onError(e){n(e),s||(c(),s=!0)}})}var q=(e,r)=>{if(!o(r))return e;const n=new Ne(M);return n.source=e,n.callable=r,n};function z(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe(e){e.addEventListener("cancel",c),o(e)},onComplete:r,onError:n})}var G=(e,r)=>{if(!o(r))return e;const n=new Ne(z);return n.source=e,n.callable=r,n};function H(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){c(),r()},onError:n})}var J=(e,r)=>{if(!o(r))return e;const n=new Ne(H);return n.source=e,n.callable=r,n};function K(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete:r,onError(e){c(e),n(e)}})}var Q=(e,r)=>{if(!o(r))return e;const n=new Ne(K);return n.source=e,n.callable=r,n};function V(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){c(),r()},onError(e){c(void 0,e),n(e)}})}var X=(e,r)=>{if(!o(r))return e;const n=new Ne(V);return n.source=e,n.callable=r,n};function Y(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe(e){c(e),o(e)},onComplete:r,onError:n})}var Z=(e,r)=>{if(!o(r))return e;const n=new Ne(Y);return n.source=e,n.callable=r,n};function $(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(e){c(),r(e)},onError(e){c(),n(e)}})}var _=(e,r)=>{if(!o(r))return e;const n=new Ne($);return n.source=e,n.callable=r,n};function ee(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),t=new x(r,n);o(t),this.promise.then(()=>t.onComplete(),e=>t.onError(e))}var re=e=>{if(!l(e))return p(new Error("Completable.fromPromise: expects a Promise-like value."));const r=new Ne(ee);return r.promise=e,r};function ne(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),t=new x(r,n);let c;o(t);try{c=this.callable()}catch(e){return void t.onError(e)}l(c)?re(c).subscribeWith({onSubscribe(e){t.setCancellable(e)},onComplete(){t.onComplete()},onError(e){t.onError(e)}}):t.onComplete()}var oe=e=>{if(!o(e))return p(new Error("Completable.fromCallable: callable received is not a function."));const r=new Ne(ne);return r.callable=e,r};function te(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),t=new x(r,n);o(t),this.subscriber(()=>t.onComplete(),e=>t.onError(e))}var ce=e=>{if(!o(e))return p(new Error("Completable.fromResolvable: expects a function."));const r=new Ne(te);return r.subscriber=e,r};function se(e){let r;try{if(r=this.operator(e),!i(r))throw new Error("Completable.lift: operator returned a non-Observer.")}catch(r){return void m(e,r)}this.source.subscribeWith(r)}var ie=(e,r)=>{if(!o(r))return e;const n=new Ne(se);return n.source=e,n.operator=r,n};function le(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this,i=[];for(const e of s){if(!(e instanceof Ne))return o(new Error("Completable.amb: One of the sources is a non-Completable.")),void c.cancel();i.unshift(e)}let l=i.length;for(const e of i)e.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){0===(l-=1)&&(n(),c.cancel())},onError(e){o(e),c.cancel()}})}var ue=e=>{if(!s(e))return p(new Error("Completable.concat: sources is not Iterable."));const r=new Ne(le);return r.sources=e,r},ae=(e,r)=>r instanceof Ne?ue([e,r]):e;function be(r){r.onSubscribe(e.UNCANCELLED)}let he;var me=()=>(void 0===he&&(he=new Ne(be)),he);function fe(r){const{onSubscribe:n,onComplete:o,onError:t}=b(r),{source:c,scheduler:s}=this,i=new e.LinkedCancellable;n(i),c.subscribeWith({onSubscribe(e){i.link(e)},onComplete(){i.link(s.schedule(o))},onError(e){i.link(s.schedule(()=>{t(e)}))}})}var pe=(e,n)=>{let o=n;o instanceof r.interface||(o=r.current);const t=new Ne(fe);return t.source=e,t.scheduler=o,t};function Ce(e){const{onComplete:r,onError:n,onSubscribe:o}=b(e),{source:t,item:c}=this;t.subscribeWith({onSubscribe:o,onComplete:r,onError(e){let o;try{o=c(e)}catch(r){return void n([e,r])}o?r():n(e)}})}var Ee=(e,r)=>{if(!o(r))return e;const n=new Ne(Ce);return n.source=e,n.item=r,n};function de(r){const{onComplete:n,onError:t,onSubscribe:c}=b(r),{source:s,resumeIfError:i}=this,l=new e.LinkedCancellable;c(l),s.subscribeWith({onSubscribe(e){l.link(e)},onComplete:n,onError(e){let r;if(l.unlink(),o(i))try{if(!((r=i(e))instanceof Ne))throw new Error("Completable.onErrorResumeNext: returned an non-Completable.")}catch(r){return t(new Error([e,r])),void l.cancel()}else r=i;r.subscribeWith({onSubscribe(e){l.link(e)},onComplete:n,onError:t})}})}var we=(e,r)=>{if(!(o(r)||r instanceof Ne))return e;const n=new Ne(de);return n.source=e,n.resumeIfError=r,n};function Se(r){const{onSubscribe:n,onComplete:o,onError:c}=b(r),s=new e.LinkedCancellable;n(s);const{source:i,times:l}=this;let u=-1;const a=()=>{s.unlink(),u+=1,i.subscribeWith({onSubscribe(e){s.link(e)},onComplete(){t(l)?u<=l?a():(o(),s.cancel()):a()},onError:c})};a()}var ve=(e,r)=>{if(null!=r){if(!t(r))return e;if(r<=0)return e}const n=new Ne(Se);return n.source=e,n.times=r,n};function ke(r){const{onSubscribe:n,onComplete:t,onError:c}=b(r),s=new e.LinkedCancellable;n(s);const{source:i,predicate:l}=this,u=()=>{s.unlink(),i.subscribeWith({onSubscribe(e){s.link(e)},onComplete(){if(o(l)){l()?(t(),s.cancel()):u()}else u()},onError:c})};u()}var We=(e,r)=>{const n=new Ne(ke);return n.source=e,n.predicate=r,n};function ye(r){const{onSubscribe:n,onComplete:t,onError:c}=b(r),s=new e.LinkedCancellable;n(s);const{source:i,bipredicate:l}=this;let u=-1;const a=()=>{s.unlink(),u+=1,i.subscribeWith({onSubscribe(e){s.link(e)},onComplete:t,onError(e){if(o(l)){l(u,e)?a():(c(e),s.cancel())}else a()}})};a()}var Le=(e,r)=>{const n=new Ne(ye);return n.source=e,n.bipredicate=r,n},Oe=(e,r)=>r instanceof Ne?S([r,e]):e;function ge(r){const{onSubscribe:n,onComplete:o,onError:t}=b(r),{source:c,scheduler:s}=this,i=new e.LinkedCancellable;n(i),i.link(s.schedule(()=>{i.unlink(),c.subscribeWith({onSubscribe(e){i.link(e)},onComplete:o,onError:t})}))}var Pe=(e,n)=>{let o=n;o instanceof r.interface||(o=r.current);const t=new Ne(ge);return t.source=e,t.scheduler=o,t};function xe(r){const{onSubscribe:n,onComplete:o,onError:t}=b(r),c=new e.CompositeCancellable;n(c);const{source:s,other:i}=this;i.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){t(new Error("Completable.takeUntil: Source cancelled by other Completable.")),c.cancel()},onError(e){t(new Error(["Completable.takeUntil: Source cancelled by other Completable.",e])),c.cancel()}}),s.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){o(),c.cancel()},onError(e){t(e),c.cancel()}})}const Be=(e,r)=>{if(!(r instanceof Ne))return e;const n=new Ne(xe);return n.source=e,n.other=r,n};function Ie(r){const{onComplete:n,onError:o,onSubscribe:t}=b(r),{amount:c,scheduler:s}=this,i=new e.LinkedCancellable;t(i);const l=s.delay(()=>{o(new Error("Completable.timeout: TimeoutException (no success signals within the specified timeout).")),i.cancel()},c);i.addEventListener("cancel",()=>l.cancel()),this.source.subscribeWith({onSubscribe(e){i.link(e)},onComplete:n,onError:o})}var Te=(e,n,o)=>{if(!t(n))return e;let c=o;c instanceof r.interface||(c=r.current);const s=new Ne(Ie);return s.source=e,s.amount=n,s.scheduler=c,s};function Ue(e){const{onComplete:r,onSubscribe:n}=b(e);n(this.scheduler.delay(r,this.amount))}var Ae=(e,n)=>{if(!t(e))return p(new Error('Completable.timer: "amount" is not a number.'));let o=n;o instanceof r.interface||(o=r.current);const c=new Ne(Ue);return c.amount=e,c.scheduler=o,c};class Ne{constructor(e){this.subscribeActual=e}static amb(e){return E(e)}ambWith(e){return d(this,e)}andThen(e){return v(this,e)}cache(){return W(this)}static complete(){return O()}compose(e){return g(this,e)}static concat(e){return S(e)}concatWith(e){return v(this,e)}static create(e){return I(e)}static defer(e){return U(e)}delay(e,r,n){return N(this,e,r,n)}delaySubscription(e,r){return D(this,e,r)}doAfterTerminate(e){return F(this,e)}doFinally(e){return q(this,e)}doOnCancel(e){return G(this,e)}doOnComplete(e){return J(this,e)}doOnError(e){return Q(this,e)}doOnEvent(e){return X(this,e)}doOnSubscribe(e){return Z(this,e)}doOnTerminate(e){return _(this,e)}static error(e){return p(e)}static fromCallable(e){return oe(e)}static fromPromise(e){return re(e)}static fromResolvable(e){return ce(e)}lift(e){return ie(this,e)}static merge(e){return ue(e)}mergeWith(e){return ae(this,e)}static never(){return me()}observeOn(e){return pe(this,e)}onErrorComplete(e){return Ee(this,e)}onErrorResumeNext(e){return we(this,e)}repeat(e){return ve(this,e)}retry(e){return Le(this,e)}repeatUntil(e){return We(this,e)}startWith(e){return Oe(this,e)}subscribeOn(e){return Pe(this,e)}takeUntil(e){return Be(this,e)}timeout(e,r){return Te(this,e,r)}static timer(e,r){return Ae(e,r)}subscribeWith(e){i(e)&&this.subscribeActual.call(this,e)}subscribe(r,n){const o=new e.LinkedCancellable;return this.subscribeWith({onSubscribe(e){o.link(e)},onComplete:r,onError:n}),o}toPromise(){return new Promise((e,r)=>{this.subscribe(e,r)})}then(e,r){return this.toPromise().then(e,r)}catch(e){return this.toPromise().catch(e)}}return Ne}(Cancellable,Scheduler);