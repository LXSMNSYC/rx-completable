var Completable=function(e,r){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r;const n=(e,r)=>typeof e===r,o=e=>n(e,"function"),t=e=>n(e,"number"),c=e=>n(e,"object"),s=e=>null==e,l=e=>null!=e,i=(e,r)=>e instanceof r,u=e=>i(e,Array),a=e=>c(e)&&o(e[Symbol.iterator]),b=e=>c(e)&&o(e.onSubscribe),h=e=>null!=e&&(!!i(e,Promise)||(c(e)||o(e))&&o(e.then)),m=e=>e,p=e=>{throw e},C=e=>({onSubscribe:e.onSubscribe,onComplete:o(e.onComplete)?e.onComplete:m,onError:o(e.onError)?e.onError:p}),f=(r,n)=>{const{onSubscribe:o,onError:t}=C(r),c=new e.BooleanCancellable;o(c),c.cancelled||(t(n),c.cancel())};function E(e){let r;try{if(r=this.supplier(),s(r))throw new Error("Completable.error: Error supplier returned a null value.")}catch(e){r=e}f(e,r)}var d=e=>{let r=e;i(e,Error)||o(e)||(r=new Error("Completable.error received a non-Error value.")),o(r)||(r=(e=>()=>e)(r));const n=new He(E);return n.supplier=r,n},w=e=>e instanceof He;function S(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this;for(const e of s){if(c.cancelled)return;if(!w(e)){o(new Error("Completable.amb: One of the sources is a non-Completable.")),c.cancel();break}e.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){n(),c.cancel()},onError(e){o(e),c.cancel()}})}}var v=e=>{if(!a(e))return d(new Error("Completable.amb: sources is not Iterable."));const r=new He(S);return r.sources=e,r};function k(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),{sources:c}=this,{length:s}=c;if(0===s)f(r,new Error("Completable.ambArray: sources Array is empty."));else{const r=new e.CompositeCancellable;t(r);for(let e=0;e<s;e+=1){const t=c[e];if(r.cancelled)return;if(!w(t)){o(new Error("Completable.ambArray: One of the sources is a non-Completable.")),r.cancel();break}t.subscribeWith({onSubscribe(e){r.add(e)},onComplete(){n(),r.cancel()},onError(e){o(e),r.cancel()}})}}}var y=e=>{if(!u(e))return d(new Error("Completable.ambArray: sources is not an Array."));const r=new He(k);return r.sources=e,r},W=(e,r)=>w(r)?y([e,r]):e;function A(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),c=new e.LinkedCancellable;t(c);const{sources:s}=this,{length:l}=s;for(let e=0;e<l;e+=1){const r=s[e];if(!w(r))return o(new Error("Completable.concatArray: One of the sources is a non-Completable.")),void c.cancel()}let i=0;const u=()=>{c.unlink(),s[0].subscribeWith({onSubscribe(e){c.link(e)},onComplete(){(i+=1)===l?n():u()},onError:o})};u()}var L=e=>{if(!u(e))return d(new Error("Completable.concatArray: sources is non-Array."));const r=new He(A);return r.sources=e,r},O=(e,r)=>w(r)?L([e,r]):e;function g(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),{source:c,cached:l,observers:i,subscribed:u}=this;if(l){const r=new e.BooleanCancellable;t(r);const{error:c}=this;s(c)?o(c):n(),r.cancel()}else{const n=i.length;i[n]=r;const o=new e.BooleanCancellable;o.addEventListener("cancel",()=>{i.splice(n,1)}),t(o),u||(c.subscribeWith({onSubscribe(){},onComplete:()=>{this.cached=!0;for(const e of i)e.onComplete();o.cancel(),this.observers=void 0},onError:e=>{this.cached=!0,this.error=e;for(const r of i)r.onError(e);o.cancel(),this.observers=void 0}}),this.subscribed=!0)}}var P=e=>{const r=new He(g);return r.source=e,r.cached=!1,r.subscribed=!1,r.observers=[],r};let x;var B=()=>(s(x)&&(x=new He(r=>(r=>{const{onSubscribe:n,onComplete:o}=C(r),t=new e.BooleanCancellable;n(t),t.cancelled||(o(),t.cancel())})(r))),x),I=(e,r)=>{if(!o(r))return e;let n;try{if(n=r(e),!w(n))throw new Error("Completable.compose: transformer returned a non-Completable.")}catch(e){n=d(e)}return n};function T(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),c=new e.LinkedCancellable;t(c);const{sources:s}=this,l=[];for(const e of s){if(!w(e))return o(new Error("Completable.concat: One of the sources is a non-Completable.")),void c.cancel();l.push(e)}const{length:i}=l;let u=0;const a=()=>{c.unlink(),l[0].subscribeWith({onSubscribe(e){c.link(e)},onComplete(){(u+=1)===i?n():a()},onError:o})};a()}var U=e=>{if(!a(e))return d(new Error("Completable.concat: sources is not Iterable."));const r=new He(T);return r.sources=e,r};class N extends e.Cancellable{constructor(r,n){super(),this.complete=r,this.error=n,this.link=new e.BooleanCancellable}get cancelled(){return this.link.cancelled}cancel(){return this.link.cancel()}setCancellable(r){if(r instanceof e.Cancellable){if(!this.cancelled){if(r.cancelled)return this.cancel(),!0;{const{link:e}=this;return this.link=r,e.cancel(),!0}}r.cancel()}return!1}onComplete(){if(!this.cancelled)try{this.complete()}finally{this.cancel()}}onError(e){let r=e;if(e instanceof Error||(r=new Error("onError called with a non-Error value.")),!this.cancelled)try{this.error(r)}finally{this.cancel()}}}function R(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),t=new N(r,n);o(t);try{this.subscriber(t)}catch(e){t.onError(e)}}var D=e=>{if(!o(e))return d(new Error("Completable.create: There are no subscribers."));const r=new He(R);return r.subscriber=e,r};function j(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e);let t,c;try{if(t=this.supplier(),!w(t))throw new Error("Completable.defer: supplier returned a non-Completable.")}catch(e){c=e}l(c)?f(e,c):t.subscribeWith({onSubscribe:o,onComplete:r,onError:n})}var F=e=>{const r=new He(j);return r.supplier=e,r};function q(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),{amount:c,scheduler:s,doDelayError:l}=this,i=new e.LinkedCancellable;t(i),this.source.subscribeWith({onSubscribe(e){i.link(e)},onComplete(){i.link(s.delay(()=>{n()},c))},onError(e){i.link(s.delay(()=>{o(e)},l?c:0))}})}var z=(e,n,o,c)=>{if(!t(n))return e;let s=o;i(s,r.interface)||(s=r.current);const l=new He(q);return l.source=e,l.amount=n,l.scheduler=s,l.doDelayError=c,l};function G(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),{amount:c,scheduler:s}=this,l=new e.LinkedCancellable;t(l),l.link(s.delay(()=>{l.unlink(),this.source.subscribeWith({onSubscribe(e){l.link(e)},onComplete:n,onError:o})},c))}var H=(e,n,o)=>{if(!t(n))return e;let c=o;i(c,r.interface)||(c=r.current);const s=new He(G);return s.source=e,s.amount=n,s.scheduler=c,s};function J(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){r(),c()},onError(e){n(e),c()}})}var K=(e,r)=>{if(!o(r))return e;const n=new He(J);return n.source=e,n.callable=r,n};function M(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;let s=!1;t.subscribeWith({onSubscribe(e){e.addEventListener("cancel",()=>{s||(c(),s=!0)}),o(e)},onComplete(){r(),s||(c(),s=!0)},onError(e){n(e),s||(c(),s=!0)}})}var Q=(e,r)=>{if(!o(r))return e;const n=new He(M);return n.source=e,n.callable=r,n};function V(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe(e){e.addEventListener("cancel",c),o(e)},onComplete:r,onError:n})}var X=(e,r)=>{if(!o(r))return e;const n=new He(V);return n.source=e,n.callable=r,n};function Y(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){c(),r()},onError:n})}var Z=(e,r)=>{if(!o(r))return e;const n=new He(Y);return n.source=e,n.callable=r,n};function $(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete:r,onError(e){c(e),n(e)}})}var _=(e,r)=>{if(!o(r))return e;const n=new He($);return n.source=e,n.callable=r,n};function ee(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(){c(),r()},onError(e){c(void 0,e),n(e)}})}var re=(e,r)=>{if(!o(r))return e;const n=new He(ee);return n.source=e,n.callable=r,n};function ne(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe(e){c(e),o(e)},onComplete:r,onError:n})}var oe=(e,r)=>{if(!o(r))return e;const n=new He(ne);return n.source=e,n.callable=r,n};function te(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,callable:c}=this;t.subscribeWith({onSubscribe:o,onComplete(e){c(),r(e)},onError(e){c(),n(e)}})}var ce=(e,r)=>{if(!o(r))return e;const n=new He(te);return n.source=e,n.callable=r,n};function se(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),t=new N(r,n);o(t),this.promise.then(()=>t.onComplete(),e=>t.onError(e))}var le=e=>{if(!h(e))return d(new Error("Completable.fromPromise: expects a Promise-like value."));const r=new He(se);return r.promise=e,r};function ie(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),t=new N(r,n);let c;o(t);try{c=this.callable()}catch(e){return void t.onError(e)}h(c)?le(c).subscribeWith({onSubscribe(e){t.setCancellable(e)},onComplete(){t.onComplete()},onError(e){t.onError(e)}}):t.onComplete()}var ue=e=>{if(!o(e))return d(new Error("Completable.fromCallable: callable received is not a function."));const r=new He(ie);return r.callable=e,r};function ae(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),t=new N(r,n);o(t),this.subscriber(()=>t.onComplete(),e=>t.onError(e))}var be=e=>{if(!o(e))return d(new Error("Completable.fromResolvable: expects a function."));const r=new He(ae);return r.subscriber=e,r};function he(e){let r;try{if(r=this.operator(e),!b(r))throw new Error("Completable.lift: operator returned a non-Observer.")}catch(r){return void f(e,r)}this.source.subscribeWith(r)}var me=(e,r)=>{if(!o(r))return e;const n=new He(he);return n.source=e,n.operator=r,n};function pe(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this,l=[];for(const e of s){if(!w(e))return o(new Error("Completable.merge: One of the sources is a non-Completable.")),void c.cancel();l.unshift(e)}let i=l.length;for(const e of l)e.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){0===(i-=1)&&(n(),c.cancel())},onError(e){o(e),c.cancel()}})}var Ce=e=>{if(!a(e))return d(new Error("Completable.merge: sources is not Iterable."));const r=new He(pe);return r.sources=e,r};function fe(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),c=new e.CompositeCancellable;t(c);const{sources:s}=this,{length:l}=s;for(let e=0;e<l;e+=1){const r=s[e];if(!w(r))return o(new Error("Completable.mergeArray: One of the sources is a non-Completable.")),void c.cancel()}let i=l;for(let e=0;e<l;e+=1){s[e].subscribeWith({onSubscribe(e){c.add(e)},onComplete(){0===(i-=1)&&(n(),c.cancel())},onError(e){o(e),c.cancel()}})}}var Ee=e=>{if(!u(e))return d(new Error("Completable.merge: sources is non-Array."));const r=new He(fe);return r.sources=e,r},de=(e,r)=>w(r)?Ee([e,r]):e;function we(r){r.onSubscribe(e.UNCANCELLED)}let Se;var ve=()=>(void 0===Se&&(Se=new He(we)),Se);function ke(r){const{onSubscribe:n,onComplete:o,onError:t}=C(r),{source:c,scheduler:s}=this,l=new e.LinkedCancellable;n(l),c.subscribeWith({onSubscribe(e){l.link(e)},onComplete(){l.link(s.schedule(o))},onError(e){l.link(s.schedule(()=>{t(e)}))}})}var ye=(e,n)=>{let o=n;i(o,r.interface)||(o=r.current);const t=new He(ke);return t.source=e,t.scheduler=o,t};function We(e){const{onComplete:r,onError:n,onSubscribe:o}=C(e),{source:t,item:c}=this;t.subscribeWith({onSubscribe:o,onComplete:r,onError(e){let o;try{o=c(e)}catch(r){return void n([e,r])}o?r():n(e)}})}var Ae=(e,r)=>{if(!o(r))return e;const n=new He(We);return n.source=e,n.item=r,n};function Le(r){const{onComplete:n,onError:t,onSubscribe:c}=C(r),{source:s,resumeIfError:l}=this,i=new e.LinkedCancellable;c(i),s.subscribeWith({onSubscribe(e){i.link(e)},onComplete:n,onError(e){let r;if(i.unlink(),o(l))try{if(!((r=l(e))instanceof He))throw new Error("Completable.onErrorResumeNext: returned an non-Completable.")}catch(r){return t(new Error([e,r])),void i.cancel()}else r=l;r.subscribeWith({onSubscribe(e){i.link(e)},onComplete:n,onError:t})}})}var Oe=(e,r)=>{if(!(o(r)||r instanceof He))return e;const n=new He(Le);return n.source=e,n.resumeIfError=r,n};function ge(r){const{onSubscribe:n,onComplete:o,onError:c}=C(r),s=new e.LinkedCancellable;n(s);const{source:l,times:i}=this;let u=-1;const a=()=>{s.unlink(),u+=1,l.subscribeWith({onSubscribe(e){s.link(e)},onComplete(){t(i)?u<=i?a():(o(),s.cancel()):a()},onError:c})};a()}var Pe=(e,r)=>{if(l(r)){if(!t(r))return e;if(r<=0)return e}const n=new He(ge);return n.source=e,n.times=r,n};function xe(r){const{onSubscribe:n,onComplete:t,onError:c}=C(r),s=new e.LinkedCancellable;n(s);const{source:l,predicate:i}=this,u=()=>{s.unlink(),l.subscribeWith({onSubscribe(e){s.link(e)},onComplete(){if(o(i)){i()?(t(),s.cancel()):u()}else u()},onError:c})};u()}var Be=(e,r)=>{const n=new He(xe);return n.source=e,n.predicate=r,n};function Ie(r){const{onSubscribe:n,onComplete:t,onError:c}=C(r),s=new e.LinkedCancellable;n(s);const{source:l,bipredicate:i}=this;let u=-1;const a=()=>{s.unlink(),u+=1,l.subscribeWith({onSubscribe(e){s.link(e)},onComplete:t,onError(e){if(o(i)){i(u,e)?a():(c(e),s.cancel())}else a()}})};a()}var Te=(e,r)=>{const n=new He(Ie);return n.source=e,n.bipredicate=r,n},Ue=(e,r)=>w(r)?L([r,e]):e;function Ne(r){const{onSubscribe:n,onComplete:o,onError:t}=C(r),{source:c,scheduler:s}=this,l=new e.LinkedCancellable;n(l),l.link(s.schedule(()=>{l.unlink(),c.subscribeWith({onSubscribe(e){l.link(e)},onComplete:o,onError:t})}))}var Re=(e,n)=>{let o=n;i(o,r.interface)||(o=r.current);const t=new He(Ne);return t.source=e,t.scheduler=o,t};function De(r){const{onSubscribe:n,onComplete:o,onError:t}=C(r),c=new e.CompositeCancellable;n(c);const{source:s,other:l}=this;l.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){t(new Error("Completable.takeUntil: Source cancelled by other Completable.")),c.cancel()},onError(e){t(new Error(["Completable.takeUntil: Source cancelled by other Completable.",e])),c.cancel()}}),s.subscribeWith({onSubscribe(e){c.add(e)},onComplete(){o(),c.cancel()},onError(e){t(e),c.cancel()}})}const je=(e,r)=>{if(!w(r))return e;const n=new He(De);return n.source=e,n.other=r,n};function Fe(r){const{onComplete:n,onError:o,onSubscribe:t}=C(r),{amount:c,scheduler:s}=this,l=new e.LinkedCancellable;t(l);const i=s.delay(()=>{o(new Error("Completable.timeout: TimeoutException (no success signals within the specified timeout).")),l.cancel()},c);l.addEventListener("cancel",()=>i.cancel()),this.source.subscribeWith({onSubscribe(e){l.link(e)},onComplete:n,onError:o})}var qe=(e,n,o)=>{if(!t(n))return e;let c=o;i(c,r.interface)||(c=r.current);const s=new He(Fe);return s.source=e,s.amount=n,s.scheduler=c,s};function ze(e){const{onComplete:r,onSubscribe:n}=C(e);n(this.scheduler.delay(r,this.amount))}var Ge=(e,n)=>{if(!t(e))return d(new Error('Completable.timer: "amount" is not a number.'));let o=n;i(o,r.interface)||(o=r.current);const c=new He(ze);return c.amount=e,c.scheduler=o,c};class He{constructor(e){this.subscribeActual=e}static amb(e){return v(e)}static ambArray(e){return y(e)}ambWith(e){return W(this,e)}andThen(e){return O(this,e)}cache(){return P(this)}static complete(){return B()}compose(e){return I(this,e)}static concat(e){return U(e)}static concatArray(e){return L(e)}concatWith(e){return O(this,e)}static create(e){return D(e)}static defer(e){return F(e)}delay(e,r,n){return z(this,e,r,n)}delaySubscription(e,r){return H(this,e,r)}doAfterTerminate(e){return K(this,e)}doFinally(e){return Q(this,e)}doOnCancel(e){return X(this,e)}doOnComplete(e){return Z(this,e)}doOnError(e){return _(this,e)}doOnEvent(e){return re(this,e)}doOnSubscribe(e){return oe(this,e)}doOnTerminate(e){return ce(this,e)}static error(e){return d(e)}static fromCallable(e){return ue(e)}static fromPromise(e){return le(e)}static fromResolvable(e){return be(e)}lift(e){return me(this,e)}static merge(e){return Ce(e)}static mergeArray(e){return Ee(e)}mergeWith(e){return de(this,e)}static never(){return ve()}observeOn(e){return ye(this,e)}onErrorComplete(e){return Ae(this,e)}onErrorResumeNext(e){return Oe(this,e)}repeat(e){return Pe(this,e)}retry(e){return Te(this,e)}repeatUntil(e){return Be(this,e)}startWith(e){return Ue(this,e)}subscribeOn(e){return Re(this,e)}takeUntil(e){return je(this,e)}timeout(e,r){return qe(this,e,r)}static timer(e,r){return Ge(e,r)}subscribeWith(e){b(e)&&this.subscribeActual.call(this,e)}subscribe(r,n){const o=new e.LinkedCancellable;return this.subscribeWith({onSubscribe(e){o.link(e)},onComplete:r,onError:n}),o}toPromise(){return new Promise((e,r)=>{this.subscribe(e,r)})}then(e,r){return this.toPromise().then(e,r)}catch(e){return this.toPromise().catch(e)}}return He}(Cancellable,Scheduler);