var Completable=function(r,e){"use strict";r=r&&r.hasOwnProperty("default")?r.default:r,e=e&&e.hasOwnProperty("default")?e.default:e;const o=(r,e)=>typeof r===e,t=r=>o(r,"function"),n=r=>o(r,"number"),s=r=>o(r,"object"),i=r=>s(r)&&t(r[Symbol.iterator]),b=r=>s(r)&&t(r.onSubscribe),c=r=>null!=r&&(r instanceof Promise||(s(r)||t(r))&&t(r.then));function a(){const{onComplete:r,controller:e}=this;if(!e.signal.aborted)try{r()}finally{e.abort()}}function u(r){const{onError:e,controller:o}=this;let t=r;if(r instanceof Error||(t=new Error("onError called with a non-Error value.")),!o.signal.aborted)try{e(t)}finally{o.abort()}}const l=r=>r,h=r=>{throw r},d=r=>({onSubscribe:r.onSubscribe,onComplete:t(r.onComplete)?r.onComplete:l,onError:t(r.onError)?r.onError:h}),f=e=>{const{onSubscribe:o,onComplete:t}=d(e),n=new r;o(n),n.signal.aborted||(t(),n.abort())},m=(e,o)=>{const{onSubscribe:t,onError:n}=d(e),s=new r;t(s),s.signal.aborted||(n(o),s.abort())};function E(r){let e;try{if(null==(e=this.supplier()))throw new Error("Completable.error: Error supplier returned a null value.")}catch(r){e=r}m(r,e)}var p=r=>{let e=r;r instanceof Error||"function"==typeof r||(e=new Error("Completable.error received a non-Error value.")),"function"!=typeof r&&(e=(r=>()=>r)(e));const o=new zr(E);return o.supplier=e,o};function C(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const{sources:b}=this;for(const r of b){if(i.aborted)return;if(!(r instanceof zr)){t(new Error("Completable.amb: One of the sources is a non-Completable.")),s.abort();break}r.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){o(),s.abort()},onError(r){t(r),s.abort()}})}}var v=r=>{if(!i(r))return p(new Error("Completable.amb: sources is not Iterable."));const e=new zr(C);return e.sources=r,e};function w(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const b=()=>{i.aborted||(o(),s.abort())},c=r=>{i.aborted||(t(r),s.abort())},{source:a,other:u}=this;a.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete:b,onError:c}),u.subscribeWith({onSubscribe(r){i.aborted?r.abort():i.addEventListener("abort",()=>r.abort())},onComplete:b,onError:c})}var S=(r,e)=>{if(!(e instanceof zr))return r;const o=new zr(w);return o.source=r,o.other=e,o};function W(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const{source:b,other:c}=this;b.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){c.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){o(),s.abort()},onError(r){t(r),s.abort()}})},onError(r){t(r),s.abort()}})}var g=(r,e)=>{if(!(e instanceof zr))return r;const o=new zr(W);return o.source=r,o.other=e,o};function L(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),{source:s,cached:i,observers:b,subscribed:c}=this;if(i){const e=new r;n(e);const{error:s}=this;null!=s?t(s):o(),e.abort()}else{const o=b.length;b[o]=e;const t=new r;t.signal.addEventListener("abort",()=>{b.splice(o,1)}),n(t),c||(s.subscribeWith({onSubscribe(){},onComplete:()=>{this.cached=!0;for(const r of b)r.onComplete();this.observers=void 0},onError:r=>{this.cached=!0,this.error=r;for(const e of b)e.onError(r);this.observers=void 0}}),this.subscribed=!0)}}var y=r=>{const e=new zr(L);return e.source=r,e.cached=!1,e.subscribed=!1,e.observers=[],e};function O(r){f(r)}let P;var A=()=>(void 0===P&&((P=new zr(O)).subscribeActual=O.bind(P)),P),k=(r,e)=>{if(!t(e))return r;let o;try{if(!((o=e(r))instanceof zr))throw new Error("Completable.compose: transformer returned a non-Completable.")}catch(r){o=p(r)}return o};function x(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const{sources:b}=this,c=[];for(const r of b){if(i.aborted)return;if(!(r instanceof zr)){t(new Error("Completable.amb: One of the sources is a non-Completable.")),s.abort();break}c.unshift(r)}if(i.aborted)return;let a;for(const r of c)if(void 0===a)a=(()=>{r.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){o(),s.abort()},onError(r){t(r),s.abort()}})});else{const e=a;a=(()=>{r.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){e()},onError(r){t(r),s.abort()}})})}a()}var I=r=>{if(!i(r))return p(new Error("Completable.concat: sources is not Iterable."));const e=new zr(x);return e.sources=r,e};function T(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r;s.onComplete=a.bind(this),s.onError=u.bind(this),this.controller=s,this.onComplete=o,this.onError=t,n(s);try{this.subscriber(s)}catch(r){s.onError(r)}}var R=r=>{if(!t(r))return p(new Error("Completable.create: There are no subscribers."));const e=new zr(T);return e.subscriber=r,e.subscribeActual=T.bind(e),e};function U(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r);let n,s;try{if(!((n=this.supplier())instanceof zr))throw new Error("Completable.defer: supplier returned a non-Completable.")}catch(r){s=r}null!=s?m(r,s):n.subscribeWith({onSubscribe:t,onComplete:e,onError:o})}var D=r=>{const e=new zr(U);return e.supplier=r,e};function N(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),{amount:s,scheduler:i,doDelayError:b}=this,c=new r,{signal:a}=c;n(c),a.aborted||this.source.subscribeWith({onSubscribe(r){a.addEventListener("abort",()=>{r.abort()})},onComplete(){const r=i.delay(()=>{o(),c.abort()},s);a.addEventListener("abort",()=>{r.abort()})},onError(r){const e=i.delay(()=>{t(r),c.abort()},b?s:0);a.addEventListener("abort",()=>{e.abort()})}})}var j=(r,o,t,s)=>{if(!n(o))return r;let i=t;i instanceof e.interface||(i=e.current);const b=new zr(N);return b.source=r,b.amount=o,b.scheduler=i,b.doDelayError=s,b};function F(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),{amount:s,scheduler:i}=this,b=new r,{signal:c}=b;if(n(b),c.aborted)return;const a=i.delay(()=>{this.source.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onComplete(){o(),b.abort()},onError(r){t(r),b.abort()}})},s);c.addEventListener("abort",()=>a.abort())}var q=(r,o,t)=>{if(!n(o))return r;let s=t;s instanceof e.interface||(s=e.current);const i=new zr(F);return i.source=r,i.amount=o,i.scheduler=s,i};function z(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe:t,onComplete(){e(),s()},onError(r){o(r),s()}})}var B=(r,e)=>{if(!t(e))return r;const o=new zr(z);return o.source=r,o.callable=e,o};function G(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;let i=!1;n.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",()=>{i||(s(),i=!0)}),t(r)},onComplete(){e(),i||(s(),i=!0)},onError(r){o(r),i||(s(),i=!0)}})}var H=(r,e)=>{if(!t(e))return r;const o=new zr(G);return o.source=r,o.callable=e,o};function J(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",s),t(r)},onComplete:e,onError:o})}var K=(r,e)=>{if(!t(e))return r;const o=new zr(J);return o.source=r,o.callable=e,o};function M(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe:t,onComplete(){s(),e()},onError:o})}var Q=(r,e)=>{if(!t(e))return r;const o=new zr(M);return o.source=r,o.callable=e,o};function V(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe:t,onComplete:e,onError(r){s(r),o(r)}})}var X=(r,e)=>{if(!t(e))return r;const o=new zr(V);return o.source=r,o.callable=e,o};function Y(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe:t,onComplete(){s(),e()},onError(r){s(void 0,r),o(r)}})}var Z=(r,e)=>{if(!t(e))return r;const o=new zr(Y);return o.source=r,o.callable=e,o};function $(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe(r){s(r),t(r)},onComplete:e,onError:o})}var _=(r,e)=>{if(!t(e))return r;const o=new zr($);return o.source=r,o.callable=e,o};function rr(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,callable:s}=this;n.subscribeWith({onSubscribe:t,onComplete(r){s(),e(r)},onError(r){s(),o(r)}})}var er=(r,e)=>{if(!t(e))return r;const o=new zr(rr);return o.source=r,o.callable=e,o};function or(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r;n(s),s.signal.aborted||(this.controller=s,this.onComplete=o,this.onError=t,this.promise.then(a.bind(this),u.bind(this)))}var tr=r=>{if(!c(r))return p(new Error("Completable.fromPromise: expects a Promise-like value."));const e=new zr(or);return e.promise=r,e};function nr(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r;if(n(s),s.signal.aborted)return;this.controller=s,this.onComplete=o,this.onError=t;const i=a.bind(this),b=u.bind(this);let l;try{l=this.callable()}catch(r){return void b(r)}c(l)?tr(l).subscribeWith({onSubscribe(r){s.signal.addEventListener("abort",()=>r.abort())},onComplete:i,onError:b}):i()}var sr=r=>{if(!t(r))return p(new Error("Completable.fromCallable: callable received is not a function."));const e=new zr(nr);return e.callable=r,e};function ir(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r;if(n(s),s.signal.aborted)return;this.controller=s,this.onComplete=o,this.onError=t;const i=a.bind(this),b=u.bind(this);this.subscriber(i,b)}var br=r=>{if(!t(r))return p(new Error("Completable.fromResolvable: expects a function."));const e=new zr(ir);return e.subscriber=r,e};function cr(r){let e;try{if(e=this.operator(r),!b(e))throw new Error("Completable.lift: operator returned a non-Observer.")}catch(e){return void m(r,e)}this.source.subscribeWith(e)}var ar=(r,e)=>{if(!t(e))return r;const o=new zr(cr);return o.source=r,o.operator=e,o};function ur(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const{sources:b}=this,c=[];for(const r of b){if(i.aborted)return;if(!(r instanceof zr)){t(new Error("Completable.amb: One of the sources is a non-Completable.")),s.abort();break}c.unshift(r)}if(i.aborted)return;let a=c.length;for(const r of c)r.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){0===(a-=1)&&(o(),s.abort())},onError(r){t(r),s.abort()}});(void 0)()}var lr=r=>{if(!i(r))return p(new Error("Completable.concat: sources is not Iterable."));const e=new zr(ur);return e.sources=r,e};function hr(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const{source:b,other:c}=this;let a=!1,u=!1;b.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){a=!0,u&&(o(),s.abort())},onError(r){t(r),s.abort()}}),c.subscribeWith({onSubscribe(r){i.aborted?r.abort():i.addEventListener("abort",()=>r.abort())},onComplete(){u=!0,a&&(o(),s.abort())},onError(r){t(r),s.abort()}})}var dr=(r,e)=>{if(!(e instanceof zr))return r;const o=new zr(hr);return o.source=r,o.other=e,o};const fr={signal:{aborted:!1,addEventListener:()=>{},removeEventListener:()=>{},onabort:()=>{}},abort:()=>{}};function mr(r){r.onSubscribe(fr)}let Er;var pr=()=>(void 0===Er&&((Er=new zr(mr)).subscribeActual=mr.bind(Er)),Er);function Cr(e){const{onSubscribe:o,onComplete:t,onError:n}=d(e),{source:s,scheduler:i}=this,b=new r;o(b);const{signal:c}=b;c.aborted||s.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onComplete(){i.schedule(()=>{t(),b.abort()})},onError(r){i.schedule(()=>{n(r),b.abort()})}})}var vr=(r,o)=>{let t=o;t instanceof e.interface||(t=e.current);const n=new zr(Cr);return n.source=r,n.scheduler=t,n};function wr(r){const{onComplete:e,onError:o,onSubscribe:t}=d(r),{source:n,item:s}=this;n.subscribeWith({onSubscribe:t,onComplete:e,onError(r){let t;try{t=s(r)}catch(e){return void o([r,e])}t?e():o(r)}})}var Sr=(r,e)=>{if(!t(e))return r;const o=new zr(wr);return o.source=r,o.item=e,o};function Wr(e){const{onComplete:o,onError:n,onSubscribe:s}=d(e),{source:i,resumeIfError:b}=this,c=new r,{signal:a}=c;s(c),a.aborted||i.subscribeWith({onSubscribe(r){a.addEventListener("abort",()=>r.abort())},onComplete(){o(),c.abort()},onError(r){let e;if(t(b))try{if(!((e=b(r))instanceof zr))throw new Error("Completable.onErrorResumeNext: returned an non-Completable.")}catch(e){return void n(new Error([r,e]))}else e=b;e.subscribeWith({onSubscribe(r){a.addEventListener("abort",()=>r.abort())},onComplete(){o(),c.abort()},onError(r){n(r),c.abort()}})}})}var gr=(r,e)=>{if(!(t(e)||e instanceof zr))return r;const o=new zr(Wr);return o.source=r,o.resumeIfError=e,o};function Lr(e){const{onSubscribe:o,onComplete:t,onError:s}=d(e),i=new r,{signal:b}=i;if(o(i),b.aborted)return;const{source:c,times:a}=this;let u=0;const l=()=>{b.aborted||(u+=1,c.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onComplete(){n(a)?u<=a?l():t():l()},onError(r){s(r),i.abort()}}))};l()}var yr=(r,e)=>{if(null!=e){if(!n(e))return r;if(e<=0)return r}const o=new zr(Lr);return o.source=r,o.times=e,o};function Or(e){const{onSubscribe:o,onComplete:n,onError:s}=d(e),i=new r,{signal:b}=i;if(o(i),b.aborted)return;const{source:c,predicate:a}=this,u=()=>{b.aborted||c.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onComplete(){if(t(a)){a()?n():u()}else u()},onError(r){s(r),i.abort()}})};u()}var Pr=(r,e)=>{const o=new zr(Or);return o.source=r,o.predicate=e,o};function Ar(e){const{onSubscribe:o,onComplete:n,onError:s}=d(e),i=new r,{signal:b}=i;if(o(i),b.aborted)return;const{source:c,bipredicate:a}=this;let u=0;const l=()=>{b.aborted||(u+=1,c.subscribeWith({onSubscribe(r){b.addEventListener("abort",()=>r.abort())},onComplete(){n(),i.abort()},onError(r){if(t(a)){a(u,r)?l():(s(r),i.abort())}else l()}}))};l()}var kr=(r,e)=>{const o=new zr(Ar);return o.source=r,o.bipredicate=e,o};function xr(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),s=new r,{signal:i}=s;if(n(s),i.aborted)return;const{source:b,other:c}=this;c.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){b.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){o(),s.abort()},onError(r){t(r),s.abort()}})},onError(r){t(r),s.abort()}})}var Ir=(r,e)=>{if(!(e instanceof zr))return r;const o=new zr(xr);return o.source=r,o.other=e,o};function Tr(e){const{onSubscribe:o,onComplete:t,onError:n}=d(e),{source:s,scheduler:i}=this,b=new r;o(b);const{signal:c}=b;c.aborted||i.schedule(()=>{c.aborted||s.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onComplete(){t(),b.abort()},onError(r){n(r),b.abort()}})})}var Rr=(r,o)=>{let t=o;t instanceof e.interface||(t=e.current);const n=new zr(Tr);return n.source=r,n.scheduler=t,n};function Ur(e){const{onSubscribe:o,onComplete:t,onError:n}=d(e),s=new r,{signal:i}=s;if(o(s),i.aborted)return;const{source:b,other:c}=this;c.subscribeWith({onSubscribe(r){i.addEventListener("abort",()=>r.abort())},onComplete(){n(new Error("Completable.takeUntil: Source cancelled by other Completable.")),s.abort()},onError(r){n(new Error(["Completable.takeUntil: Source cancelled by other Completable.",r])),s.abort()}}),b.subscribeWith({onSubscribe(r){i.aborted?r.abort():i.addEventListener("abort",()=>r.abort())},onComplete(){t(),s.abort()},onError(r){n(r),s.abort()}})}const Dr=(r,e)=>{if(!(e instanceof zr))return r;const o=new zr(Ur);return o.source=r,o.other=e,o};function Nr(e){const{onComplete:o,onError:t,onSubscribe:n}=d(e),{amount:s,scheduler:i}=this,b=new r,{signal:c}=b;if(n(b),c.aborted)return;const a=i.delay(()=>{t(new Error("Completable.timeout: TimeoutException (no success signals within the specified timeout).")),b.abort()},s);c.addEventListener("abort",()=>a.abort()),this.source.subscribeWith({onSubscribe(r){c.addEventListener("abort",()=>r.abort())},onComplete(){o(),b.abort()},onError(r){t(r),b.abort()}})}var jr=(r,o,t)=>{if(!n(o))return r;let s=t;s instanceof e.interface||(s=e.current);const i=new zr(Nr);return i.source=r,i.amount=o,i.scheduler=s,i};function Fr(e){const{onComplete:o,onSubscribe:t}=d(e),n=new r,{signal:s}=n;if(t(n),s.aborted)return;const i=this.scheduler.delay(()=>o(),this.amount);s.addEventListener("abort",()=>i.abort())}var qr=(r,o)=>{if(!n(r))return p(new Error('Completable.timer: "amount" is not a number.'));let t=o;t instanceof e.interface||(t=e.current);const s=new zr(Fr);return s.amount=r,s.scheduler=t,s};class zr{constructor(r){this.subscribeActual=r}static amb(r){return v(r)}ambWith(r){return S(this,r)}andThen(r){return g(this,r)}cache(){return y(this)}static complete(){return A()}compose(r){return k(this,r)}static concat(r){return I(r)}concatWith(r){return g(this,r)}static create(r){return R(r)}static defer(r){return D(r)}delay(r,e,o){return j(this,r,e,o)}delaySubscription(r,e){return q(this,r,e)}doAfterTerminate(r){return B(this,r)}doFinally(r){return H(this,r)}doOnAbort(r){return K(this,r)}doOnComplete(r){return Q(this,r)}doOnError(r){return X(this,r)}doOnEvent(r){return Z(this,r)}doOnSubscribe(r){return _(this,r)}doOnTerminate(r){return er(this,r)}static error(r){return p(r)}static fromCallable(r){return sr(r)}static fromPromise(r){return tr(r)}static fromResolvable(r){return br(r)}lift(r){return ar(this,r)}static merge(r){return lr(r)}mergeWith(r){return dr(this,r)}static never(){return pr()}observeOn(r){return vr(this,r)}onErrorComplete(r){return Sr(this,r)}onErrorResumeNext(r){return gr(this,r)}repeat(r){return yr(this,r)}retry(r){return kr(this,r)}repeatUntil(r){return Pr(this,r)}startWith(r){return Ir(this,r)}subscribeOn(r){return Rr(this,r)}takeUntil(r){return Dr(this,r)}timeout(r,e){return jr(this,r,e)}static timer(r,e){return qr(r,e)}subscribeWith(r){b(r)&&this.subscribeActual.call(this,r)}subscribe(e,o){const t=new r;let n=!1;return this.subscribeWith({onSubscribe(r){r.signal.addEventListener("abort",()=>{n||(n=!0,t.signal.aborted||t.abort())}),t.signal.addEventListener("abort",()=>{n||(n=!0,r.signal.aborted||r.abort())})},onComplete:e,onError:o}),t}toPromise(){return new Promise((r,e)=>{this.subscribe(r,e)})}then(r,e){return this.toPromise().then(r,e)}catch(r){return this.toPromise().catch(r)}}return zr}(AbortController,Scheduler);